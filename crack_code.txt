{
 "cells": [
  {
   "cell_type": "code",
   "execution_count": 33,
   "metadata": {
    "execution": {
     "iopub.execute_input": "2022-04-24T10:15:39.835990Z",
     "iopub.status.busy": "2022-04-24T10:15:39.835675Z",
     "iopub.status.idle": "2022-04-24T10:15:39.845879Z",
     "shell.execute_reply": "2022-04-24T10:15:39.845189Z",
     "shell.execute_reply.started": "2022-04-24T10:15:39.835951Z"
    }
   },
   "outputs": [],
   "source": [
    "import autogluon.core as ag\n",
    "from autogluon.vision import ImagePredictor, ImageDataset\n",
    "import pandas as pd\n",
    "import numpy as np\n",
    "from matplotlib import pyplot as plt"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 34,
   "metadata": {
    "execution": {
     "iopub.execute_input": "2022-04-24T10:15:39.849822Z",
     "iopub.status.busy": "2022-04-24T10:15:39.849411Z",
     "iopub.status.idle": "2022-04-24T10:15:40.100190Z",
     "shell.execute_reply": "2022-04-24T10:15:40.099474Z",
     "shell.execute_reply.started": "2022-04-24T10:15:39.849785Z"
    }
   },
   "outputs": [
    {
     "data": {
      "text/plain": [
       "(3142, 5000)"
      ]
     },
     "execution_count": 34,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "from glob import glob\n",
    "test_crack=glob('../input/pavement-detection-v1/pavement_detection/test/crack/*.jpg')\\\n",
    "+glob('../input/pavement-detection-v1/pavement_detection/test/massive_crack/*.jpg')\\\n",
    "+glob('../input/pavement-detection-v1/pavement_detection/test/longitudinal_crack/*.jpg')\\\n",
    "+glob('../input/pavement-detection-v1/pavement_detection/test/transverse_crack/*.jpg')\n",
    "test_nocrack=glob('../input/pavement-detection-v1/pavement_detection/test/normal/*.jpg')\n",
    "len(test_crack),len(test_nocrack)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 35,
   "metadata": {
    "execution": {
     "iopub.execute_input": "2022-04-24T10:15:40.102514Z",
     "iopub.status.busy": "2022-04-24T10:15:40.102103Z",
     "iopub.status.idle": "2022-04-24T10:15:40.686043Z",
     "shell.execute_reply": "2022-04-24T10:15:40.685317Z",
     "shell.execute_reply.started": "2022-04-24T10:15:40.102471Z"
    }
   },
   "outputs": [
    {
     "data": {
      "text/plain": [
       "(12937, 10000)"
      ]
     },
     "execution_count": 35,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "train_crack=glob('../input/pavement-detection-v1/pavement_detection/train/crack/*.jpg')\\\n",
    "+glob('../input/pavement-detection-v1/pavement_detection/train/massive_crack/*.jpg')\\\n",
    "+glob('../input/pavement-detection-v1/pavement_detection/train/longitudinal_crack/*.jpg')\\\n",
    "+glob('../input/pavement-detection-v1/pavement_detection/train/transverse_crack/*.jpg')\n",
    "train_nocrack=glob('../input/pavement-detection-v1/pavement_detection/train/normal/*.jpg')\n",
    "len(train_crack),len(train_nocrack)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 36,
   "metadata": {
    "execution": {
     "iopub.execute_input": "2022-04-24T10:15:40.687822Z",
     "iopub.status.busy": "2022-04-24T10:15:40.687431Z",
     "iopub.status.idle": "2022-04-24T10:15:40.700162Z",
     "shell.execute_reply": "2022-04-24T10:15:40.699276Z",
     "shell.execute_reply.started": "2022-04-24T10:15:40.687783Z"
    }
   },
   "outputs": [],
   "source": [
    "train_df=pd.concat([pd.DataFrame(train_crack),pd.DataFrame(train_nocrack)])\n",
    "train_df['label']=['crack']*len(train_crack)+['nocrack']*len(train_nocrack)\n",
    "train_df.columns=['image','label']"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 37,
   "metadata": {
    "execution": {
     "iopub.execute_input": "2022-04-24T10:15:40.702100Z",
     "iopub.status.busy": "2022-04-24T10:15:40.701751Z",
     "iopub.status.idle": "2022-04-24T10:15:40.710769Z",
     "shell.execute_reply": "2022-04-24T10:15:40.709784Z",
     "shell.execute_reply.started": "2022-04-24T10:15:40.702064Z"
    }
   },
   "outputs": [],
   "source": [
    "test_df=pd.concat([pd.DataFrame(test_crack),pd.DataFrame(test_nocrack)])\n",
    "test_df['label']=['crack']*len(test_crack)+['nocrack']*len(test_nocrack)\n",
    "test_df.columns=['image','label']"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 38,
   "metadata": {
    "execution": {
     "iopub.execute_input": "2022-04-24T10:15:40.712516Z",
     "iopub.status.busy": "2022-04-24T10:15:40.712203Z",
     "iopub.status.idle": "2022-04-24T11:17:12.234639Z",
     "shell.execute_reply": "2022-04-24T11:17:12.233717Z",
     "shell.execute_reply.started": "2022-04-24T10:15:40.712478Z"
    }
   },
   "outputs": [
    {
     "name": "stderr",
     "output_type": "stream",
     "text": [
      "ImagePredictor sets accuracy as default eval_metric for classification problems.\n",
      "`time_limit=auto` set to `time_limit=7200`.\n",
      "Converting raw DataFrame to ImageDataset...\n",
      "Detected 2 unique classes: ['crack', 'nocrack']\n",
      "If you feel the `classes` is inaccurate, please construct the dataset explicitly, e.g. train_data = ImageDataset(train_data, classes=[\"foo\", \"bar\"])\n",
      "Selected class <--> label mapping:  class 1 = 1, class 0 = 0\n",
      "Randomly split train_data into train[20643]/validation[2294] splits.\n",
      "Reset labels to [0, 1]\n",
      "The number of requested GPUs is greater than the number of available GPUs.Reduce the number to 1\n",
      "Starting fit without HPO\n",
      "Finished, total runtime is 3691.43 s\n",
      "{ 'best_config': { 'batch_size': 16,\n",
      "                   'dist_ip_addrs': None,\n",
      "                   'early_stop_baseline': -inf,\n",
      "                   'early_stop_max_value': inf,\n",
      "                   'early_stop_patience': 10,\n",
      "                   'epochs': 10,\n",
      "                   'final_fit': False,\n",
      "                   'gpus': [0],\n",
      "                   'lr': 0.01,\n",
      "                   'model': 'resnet50',\n",
      "                   'ngpus_per_trial': 8,\n",
      "                   'nthreads_per_trial': 128,\n",
      "                   'num_workers': 2,\n",
      "                   'searcher': 'random',\n",
      "                   'seed': 572,\n",
      "                   'time_limits': 7200},\n",
      "  'total_time': 1746.8709244728088,\n",
      "  'train_acc': 0.801889534883721,\n",
      "  'valid_acc': 0.8526591107236269}\n"
     ]
    },
    {
     "data": {
      "text/plain": [
       "<autogluon.vision.predictor.predictor.ImagePredictor at 0x7f5b80489b10>"
      ]
     },
     "execution_count": 38,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "predictor = ImagePredictor()\n",
    "predictor.fit(train_df, hyperparameters={'epochs': 10}) \n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 39,
   "metadata": {
    "execution": {
     "iopub.execute_input": "2022-04-24T11:17:12.236754Z",
     "iopub.status.busy": "2022-04-24T11:17:12.236471Z",
     "iopub.status.idle": "2022-04-24T11:17:12.243741Z",
     "shell.execute_reply": "2022-04-24T11:17:12.243049Z",
     "shell.execute_reply.started": "2022-04-24T11:17:12.236716Z"
    }
   },
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Top-1 train acc: 0.802, val acc: 0.853\n"
     ]
    }
   ],
   "source": [
    "fit_result = predictor.fit_summary()\n",
    "print('Top-1 train acc: %.3f, val acc: %.3f' %(fit_result['train_acc'], fit_result['valid_acc']))\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 40,
   "metadata": {
    "execution": {
     "iopub.execute_input": "2022-04-24T11:17:12.245484Z",
     "iopub.status.busy": "2022-04-24T11:17:12.244986Z",
     "iopub.status.idle": "2022-04-24T11:19:59.213482Z",
     "shell.execute_reply": "2022-04-24T11:19:59.212587Z",
     "shell.execute_reply.started": "2022-04-24T11:17:12.245446Z"
    }
   },
   "outputs": [],
   "source": [
    "test_result = predictor.predict(test_df)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": []
  },
  {
   "cell_type": "code",
   "execution_count": 41,
   "metadata": {
    "execution": {
     "iopub.execute_input": "2022-04-24T11:19:59.216417Z",
     "iopub.status.busy": "2022-04-24T11:19:59.216115Z",
     "iopub.status.idle": "2022-04-24T11:19:59.612325Z",
     "shell.execute_reply": "2022-04-24T11:19:59.611599Z",
     "shell.execute_reply.started": "2022-04-24T11:19:59.216379Z"
    }
   },
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "              precision    recall  f1-score   support\n",
      "\n",
      "       crack       0.80      0.85      0.82      3142\n",
      "     nocrack       0.90      0.86      0.88      5000\n",
      "\n",
      "    accuracy                           0.86      8142\n",
      "   macro avg       0.85      0.86      0.85      8142\n",
      "weighted avg       0.86      0.86      0.86      8142\n",
      "\n"
     ]
    }
   ],
   "source": [
    "from sklearn.metrics import classification_report,confusion_matrix\n",
    "print(classification_report(test_df.label,test_result))"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 42,
   "metadata": {
    "execution": {
     "iopub.execute_input": "2022-04-24T11:19:59.614034Z",
     "iopub.status.busy": "2022-04-24T11:19:59.613615Z",
     "iopub.status.idle": "2022-04-24T11:19:59.669468Z",
     "shell.execute_reply": "2022-04-24T11:19:59.668703Z",
     "shell.execute_reply.started": "2022-04-24T11:19:59.613995Z"
    }
   },
   "outputs": [
    {
     "data": {
      "text/plain": [
       "array([[2680,  462],\n",
       "       [ 680, 4320]])"
      ]
     },
     "execution_count": 42,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "confusion_matrix(test_df.label,test_result)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": []
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "Python 3",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.8.8"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 4
}
